// Generated by CoffeeScript 1.7.1
(function() {
  var Battle, GameServer, Npc, Player, Projectile, World, fs, net, path;

  fs = require('fs');

  path = require('path');

  net = require('net');

  Player = (function() {
    function Player(world, socket, name, sprite) {
      this.world = world;
      this.socket = socket;
      this.name = name;
      this.sprite = sprite;
    }

    Player.prototype.x = 0;

    Player.prototype.y = 0;

    Player.prototype.hp = 100;

    Player.prototype.isNpc = false;

    Player.prototype.battle = null;

    Player.prototype.move = function(x, y) {};

    Player.prototype.attack = function(x, y) {};

    Player.prototype.tick = function() {};

    return Player;

  })();

  Npc = (function() {
    function Npc(world, name, sprite) {
      this.world = world;
      this.name = name;
      this.sprite = sprite;
    }

    Npc.prototype.x = 0;

    Npc.prototype.y = 0;

    Npc.prototype.hp = 100;

    Npc.prototype.isNpc = true;

    Npc.prototype.battle = null;

    Npc.prototype.testTick = 0;

    Npc.prototype.move = function(x, y) {};

    Npc.prototype.attack = function(x, y) {};

    Npc.prototype.tick = function() {
      var x, y;
      this.testTick++;
      if (this.battle) {
        return;
      }
      if (this.testTick % 10 === 0) {
        x = this.x - 2 + Math.floor(Math.random() * 5);
        y = this.y - 2 + Math.floor(Math.random() * 5);
        return this.world.processNpcMove(this, x, y);
      }
    };

    return Npc;

  })();

  Projectile = (function() {
    function Projectile(world, name, sprite) {
      this.world = world;
      this.name = name;
      this.sprite = sprite;
    }

    Projectile.prototype.x = 0;

    Projectile.prototype.y = 0;

    Projectile.prototype.tick = function() {};

    return Projectile;

  })();

  Battle = (function() {
    function Battle(world, char1, char2) {
      this.world = world;
      this.char1 = char1;
      this.char2 = char2;
      this.char1.battle = this;
      this.char2.battle = this;
      this.isPvp = this.char1.isNpc || this.char2.isNpc;
      this.charList = [this.char1, this.char2];
    }

    Battle.prototype.isPvp = false;

    Battle.prototype.charList = [];

    Battle.prototype.attacker = null;

    Battle.prototype.isDefending = false;

    Battle.prototype.beginTime = Date.now();

    Battle.prototype.start = function() {
      var _ref, _ref1, _ref2, _ref3;
      if ((_ref = this.char1.socket) != null) {
        _ref.emit('sStartBattle', {
          name: this.char2.name,
          sprite: this.char2.sprite,
          isNpc: this.char2.isNpc,
          isFirst: true
        });
      }
      if ((_ref1 = this.char1.socket) != null) {
        _ref1.emit('sBattleStatus', {
          msg: 'Your Turn',
          turn: true
        });
      }
      if ((_ref2 = this.char2.socket) != null) {
        _ref2.emit('sStartBattle', {
          name: this.char1.name,
          sprite: this.char1.sprite,
          isNpc: this.char1.isNpc,
          isFirst: false
        });
      }
      if ((_ref3 = this.char2.socket) != null) {
        _ref3.emit('sBattleStatus', {
          msg: 'Waiting...',
          turn: false
        });
      }
      return this.attacker = this.char1;
    };

    Battle.prototype.getOpponent = function(char) {
      if (char === this.char1) {
        return this.char2;
      } else {
        return this.char1;
      }
    };

    Battle.prototype.processAttack = function(attacker, isSkill) {
      var attackee, damage, data, hp, maxDamage, _ref, _ref1;
      if (this.attacker !== attacker) {
        return;
      }
      maxDamage = isSkill ? 50 : 20;
      damage = Math.floor(Math.random() * maxDamage);
      if (this.isDefending) {
        damage /= 2;
      }
      this.isDefending = false;
      attackee = this.getOpponent(attacker);
      hp = attackee.hp - damage;
      if (hp < 0) {
        hp = 0;
      }
      attackee.hp = hp;
      data = {
        from: attacker.name,
        to: attackee.name,
        isSkill: isSkill,
        damage: damage,
        hp: hp
      };
      console.log('sAttack', data);
      if ((_ref = attacker.socket) != null) {
        _ref.emit('sAttack', data);
      }
      if ((_ref1 = attackee.socket) != null) {
        _ref1.emit('sAttack', data);
      }
      if (hp > 0) {
        return this.changeTurn();
      } else {
        return this.finish(attacker, attackee, false);
      }
    };

    Battle.prototype.processDefend = function(attacker) {
      if (this.attacker !== attacker) {
        return;
      }
      this.isDefending = true;
      return this.changeTurn();
    };

    Battle.prototype.changeTurn = function() {
      var nextAttacker, _ref, _ref1;
      nextAttacker = this.getOpponent(this.attacker);
      if ((_ref = nextAttacker.socket) != null) {
        _ref.emit('sBattleStatus', {
          msg: 'Your Turn',
          turn: true
        });
      }
      if ((_ref1 = this.attacker.socket) != null) {
        _ref1.emit('sBattleStatus', {
          msg: 'Waiting...',
          turn: false
        });
      }
      return this.attacker = nextAttacker;
    };

    Battle.prototype.processFlee = function(attacker) {
      if (this.attacker !== attacker) {
        return;
      }
      return this.finish(this.getOpponent(attacker), attacker, false);
    };

    Battle.prototype.aiTick = null;

    Battle.prototype.tick = function() {
      var isSkill, now;
      now = Date.now();
      if (now - this.beginTime > 5 * 60 * 1000) {
        this.finish(this.char1, this.char2, true);
        return;
      }
      if (!this.attacker.isNpc) {
        return;
      }
      if (!this.aiTick) {
        this.aiTick = now;
      }
      if ((now - this.aiTick) > (3000 + Math.random() * 2000)) {
        isSkill = Math.random() > 0.7;
        this.attacker.battle.processAttack(this.attacker, isSkill);
        return this.aiTick = null;
      }
    };

    Battle.prototype.finish = function(winner, loser, isDraw) {
      var battle, data, duration, i, _i, _len, _ref, _ref1, _ref2, _ref3, _ref4, _results;
      duration = Date.now() - this.beginTime;
      if ((_ref = this.world) != null) {
        if ((_ref1 = _ref.server) != null) {
          _ref1.sendToGcm({
            msgType: 'battleResult',
            body: {
              isDraw: isDraw,
              duration: duration,
              pos: {
                x: winner.x,
                y: winner.y
              },
              winner: {
                id: winner.name,
                isNpc: winner.isNpc
              },
              loser: {
                id: loser.name,
                isNpc: loser.isNpc
              },
              reward: {
                exp: 20,
                gold: 100
              },
              time: Date.now()
            }
          });
        }
      }
      data = {
        winner: winner.name,
        loser: loser.name,
        isDraw: isDraw
      };
      if ((_ref2 = winner.socket) != null) {
        _ref2.emit('sEndBattle', data);
      }
      if ((_ref3 = loser.socket) != null) {
        _ref3.emit('sEndBattle', data);
      }
      winner.hp = 100;
      loser.hp = 100;
      winner.battle = null;
      loser.battle = null;
      _ref4 = this.world.battleList;
      _results = [];
      for (i = _i = 0, _len = _ref4.length; _i < _len; i = ++_i) {
        battle = _ref4[i];
        if (battle === this) {
          this.world.battleList.splice(i, 1);
          break;
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    return Battle;

  })();

  World = (function() {
    function World(server) {
      this.server = server;
    }

    World.prototype.playerIdTable = {};

    World.prototype.playerNameTable = {};

    World.prototype.npcTable = {};

    World.prototype.projectileTable = {};

    World.prototype.npcSpriteList = [];

    World.prototype.maxNpc = 30;

    World.prototype.mapWidth = 1200;

    World.prototype.mapHeight = 900;

    World.prototype.index = 0;

    World.prototype.battleList = [];

    World.prototype.processLogin = function(socket) {
      var k, player, playerSocket, v, _ref, _ref1, _results;
      player = this.playerIdTable[socket.id];
      if (!player) {
        return;
      }
      playerSocket = player.socket;
      playerSocket.emit('sLogin', {
        name: player.name,
        sprite: player.sprite
      });
      _ref = this.playerNameTable;
      for (k in _ref) {
        v = _ref[k];
        if (!(v.name !== player.name)) {
          continue;
        }
        playerSocket.emit('sPcMove', {
          name: v.name,
          sprite: v.sprite,
          x: v.x,
          y: v.y
        });
        v.socket.emit('sPcMove', {
          name: player.name,
          sprite: player.sprite,
          x: player.x,
          y: player.y
        });
      }
      _ref1 = this.npcTable;
      _results = [];
      for (k in _ref1) {
        v = _ref1[k];
        _results.push(playerSocket.emit('sNpcMove', {
          name: v.name,
          sprite: v.sprite,
          x: v.x,
          y: v.y
        }));
      }
      return _results;
    };

    World.prototype.processLogout = function(socket) {
      var player, playerSocket;
      player = this.playerIdTable[socket.id];
      if (!player) {
        return;
      }
      playerSocket = player.socket;
      playerSocket.broadcast.emit('sQuit', player.name);
      delete this.playerIdTable[playerSocket.id];
      return delete this.playerNameTable[player.name];
    };

    World.prototype.processPcMove = function(socket, x, y) {
      var player, playerSocket;
      player = this.playerIdTable[socket.id];
      if (!player) {
        return;
      }
      playerSocket = player.socket;
      player.x = x;
      player.y = y;
      return playerSocket.broadcast.emit('sPcMove', {
        name: player.name,
        sprite: player.sprite,
        x: player.x,
        y: player.y
      });
    };

    World.prototype.getDistance = function(char1, char2) {
      var dX, dY, _ref;
      _ref = [char1.x - char2.x, char1.y - char2.y], dX = _ref[0], dY = _ref[1];
      return Math.sqrt(dX * dX + dY * dY);
    };

    World.prototype.getFirstCandidate = function(char, table) {
      var dist, k, v;
      for (k in table) {
        v = table[k];
        dist = this.getDistance(char, v);
        if (char !== v && dist < 50 && v.battle === null) {
          return v;
        }
      }
      return null;
    };

    World.prototype.processStartBattle = function(socket, x, y) {
      var battle, opponent, player, playerSocket;
      player = this.playerIdTable[socket.id];
      if (!player) {
        return;
      }
      if (player.battle) {
        return;
      }
      playerSocket = player.socket;
      opponent = this.getFirstCandidate(player, this.playerIdTable);
      if (!opponent) {
        opponent = this.getFirstCandidate(player, this.npcTable);
      }
      if (!opponent) {
        return;
      }
      battle = new Battle(this, player, opponent);
      this.battleList.push(battle);
      return battle.start();
    };

    World.prototype.processAttack = function(socket, isSkill) {
      var player, _ref;
      player = this.playerIdTable[socket.id];
      if (!player) {
        return;
      }
      return (_ref = player.battle) != null ? _ref.processAttack(player, isSkill) : void 0;
    };

    World.prototype.processDefend = function(socket) {
      var player, _ref;
      player = this.playerIdTable[socket.id];
      if (!player) {
        return;
      }
      return (_ref = player.battle) != null ? _ref.processDefend(player) : void 0;
    };

    World.prototype.processFlee = function(socket) {
      var player, _ref;
      player = this.playerIdTable[socket.id];
      if (!player) {
        return;
      }
      return (_ref = player.battle) != null ? _ref.processFlee(player) : void 0;
    };

    World.prototype.processNpcMove = function(npc, x, y) {
      var k, v, _ref, _results;
      npc.x = x;
      npc.y = y;
      _ref = this.playerNameTable;
      _results = [];
      for (k in _ref) {
        v = _ref[k];
        _results.push(v.socket.emit('sNpcMove', {
          name: npc.name,
          sprite: npc.sprite,
          x: npc.x,
          y: npc.y
        }));
      }
      return _results;
    };

    World.prototype.processChat = function(from, to, msg) {
      var player, playerSocket;
      player = this.playerNameTable[from];
      if (!player) {
        return;
      }
      playerSocket = player.socket;
      playerSocket.emit('sChat', {
        from: from,
        msg: msg
      });
      return playerSocket.broadcast.emit('sChat', {
        from: from,
        msg: msg
      });
    };

    World.prototype.spawnNpc = function() {
      var k, npc, rand, v, _ref, _results;
      rand = Math.floor(Math.random() * this.npcSpriteList.length);
      npc = new Npc(this, "" + this.index + "_test", this.npcSpriteList[rand]);
      npc.x = Math.floor(Math.random() * this.mapWidth);
      npc.y = Math.floor(Math.random() * this.mapHeight);
      this.npcTable[npc.name] = npc;
      this.index++;
      _ref = this.playerNameTable;
      _results = [];
      for (k in _ref) {
        v = _ref[k];
        _results.push(v.socket.emit('sNpcMove', {
          name: npc.name,
          sprite: npc.sprite,
          x: npc.x,
          y: npc.y
        }));
      }
      return _results;
    };

    World.prototype.tick = function() {
      var battle, k, nowNpc, v, _i, _len, _ref, _ref1, _ref2, _ref3;
      _ref = this.projectileTable;
      for (k in _ref) {
        v = _ref[k];
        v.tick();
      }
      _ref1 = this.npcTable;
      for (k in _ref1) {
        v = _ref1[k];
        v.tick();
      }
      _ref2 = this.playerIdTable;
      for (k in _ref2) {
        v = _ref2[k];
        v.tick();
      }
      _ref3 = this.battleList;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        battle = _ref3[_i];
        battle.tick();
      }
      nowNpc = (function() {
        var _ref4, _results;
        _ref4 = this.npcTable;
        _results = [];
        for (k in _ref4) {
          v = _ref4[k];
          _results.push(v);
        }
        return _results;
      }).call(this);
      if (nowNpc.length < this.maxNpc) {
        return this.spawnNpc();
      }
    };

    World.prototype.loadDatasheet = function() {
      var dataDir, file, fileList, loadFromCsv, npcTemplateCsv, npcTemplateTable, skillTemplateTable, skillTeplateCsv, spawnTemplateCsv, spawnTemplateTable;
      dataDir = path.join(__dirname, 'data');
      skillTeplateCsv = path.join(dataDir, 'skill.csv');
      npcTemplateCsv = path.join(dataDir, 'npc.csv');
      spawnTemplateCsv = path.join(dataDir, 'spawn.csv');
      loadFromCsv = function(csvPath, onLoadRecord) {
        var line, lines, text, _i, _len, _results;
        text = fs.readFileSync(csvPath, 'utf8');
        lines = text.split('\n');
        _results = [];
        for (_i = 0, _len = lines.length; _i < _len; _i++) {
          line = lines[_i];
          if (line.trim().length > 0) {
            _results.push(onLoadRecord(line.split(',')));
          }
        }
        return _results;
      };
      skillTemplateTable = {};
      loadFromCsv(skillTeplateCsv, function(record) {
        var atk, coolTime, id, name;
        id = record[0], name = record[1], atk = record[2], coolTime = record[3];
        id = parseInt(id);
        atk = parseInt(atk);
        coolTime = parseInt(coolTime);
        return skillTemplateTable[id] = new SkillTemplate(id, name, atk, coolTime);
      });
      npcTemplateTable = {};
      loadFromCsv(npcTemplateCsv, function(record) {
        var hp, id, name, skill, skillList, skillListStr, skillTemplateId, sprite, _i, _len, _ref;
        id = record[0], name = record[1], sprite = record[2], hp = record[3], skillListStr = record[4];
        id = parseInt(id);
        hp = parseInt(hp);
        skillList = [];
        _ref = skillListStr.split(';');
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          skillTemplateId = _ref[_i];
          skill = skillTemplateTable[skillTemplateId];
          if (skill) {
            skillList.push(skill);
          }
        }
        return npcTemplateTable[id] = new NpcTemplate(id, name, sprite, hp, skillList);
      });
      spawnTemplateTable = {};
      loadFromCsv(spawnTemplateCsv, function(record) {
        var id, npcTemplate, npcTemplateId, respawnMsec, x, y;
        id = record[0], npcTemplateId = record[1], x = record[2], y = record[3], respawnMsec = record[4];
        id = parseInt(id);
        npcTemplateId = parseInt(npcTemplateId);
        x = parseInt(x);
        y = parseInt(y);
        respawnMsec = parseInt(respawnMsec);
        npcTemplate = npcTemplateTable[npcTemplateId];
        if (npcTemplate) {
          return spawnTemplateTable[id] = new SpawnTemplate(id, npcTemplate, x, y, respawnMsec);
        }
      });
      fileList = fs.readdirSync(path.join(__dirname, 'public', 'res', 'npc'));
      return this.npcSpriteList = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = fileList.length; _i < _len; _i++) {
          file = fileList[_i];
          if (/\.png$/.test(file)) {
            _results.push(file.substring(0, file.length - 4));
          }
        }
        return _results;
      })();
    };

    World.prototype.init = function() {
      this.loadDatasheet();
      return setInterval((function(_this) {
        return function() {
          return _this.tick();
        };
      })(this), 100);
    };

    World.prototype.createPlayer = function(socket, name, sprite) {
      var player;
      player = new Player(this, socket, name, sprite);
      this.playerIdTable[socket.id] = player;
      this.playerNameTable[player.name] = player;
      return this.processLogin(socket);
    };

    return World;

  })();

  GameServer = (function() {
    var makePacket;

    function GameServer(httpServer) {
      this.httpServer = httpServer;
    }

    GameServer.prototype.init = function() {
      this.handleConnection();
      this.connectToGcm('127.0.0.1', 1338);
      this.world = new World(this);
      return this.world.init();
    };

    GameServer.prototype.getPlayerBySocket = function(socket) {
      return this.world.playerIdTable[socket.id];
    };

    GameServer.prototype.handleConnection = function() {
      var io;
      io = require('socket.io').listen(this.httpServer);
      io.set('log level', '1');
      return io.on('connection', (function(_this) {
        return function(socket) {
          console.log(socket.id);

          /*
              i = Math.floor Math.random() * maleNames.length
              j = Math.floor Math.random() * sprites.length
              myName = maleNames[i]
              mySprite = sprites[j]
              playerTable[socket.id] = new Player myName, mySprite
              maleNames.splice i, 1
              socket.emit 'sConnection', { name: myName, sprite: mySprite }
           */
          socket.on('cMove', function(data) {
            var now, player;
            _this.world.processPcMove(socket, data.x, data.y);
            now = Date.now();
            if (now - _this.lastActionTime < 500) {
              return;
            }
            _this.lastActionTime = now;
            if (_this.gcmClient) {
              player = _this.getPlayerBySocket(socket);
              return _this.sendToGcm({
                msgType: 'move',
                body: {
                  id: player != null ? player.name : void 0,
                  src: {
                    x: player.x,
                    y: player.y
                  },
                  dest: {
                    x: data.x,
                    y: data.y
                  },
                  time: now
                }
              });
            }
          });
          socket.on('cStartBattle', function(data) {
            return _this.world.processStartBattle(socket, data.x, data.y);
          });
          socket.on('cAttack', function(data) {
            console.log('cAttack', data);
            return _this.world.processAttack(socket, data.isSkill);
          });
          socket.on('cDefend', function(data) {
            return _this.world.processDefend(socket);
          });
          socket.on('cFlee', function(data) {
            return _this.world.processFlee(socket);
          });
          socket.on('cLogin', function(data) {
            return _this.world.createPlayer(socket, data.name, data.sprite, data.x, data.y);
          });
          socket.on('cChat', function(data) {
            if (_this.gcmClient) {
              return _this.sendToGcm({
                msgType: 'chat',
                body: {
                  user: data.from,
                  msg: data.msg,
                  time: Date.now()
                }
              });
            } else {
              return _this.world.processChat(data.from, null, data.msg);
            }
          });
          return socket.on('disconnect', function() {
            return _this.world.processLogout(socket);
          });
        };
      })(this));
    };

    makePacket = function(jsonData) {
      var body, header, packet;
      body = new Buffer(JSON.stringify(jsonData), 'utf8');
      header = new Buffer("" + body.length + "\r\n\r\n", 'utf8');
      packet = new Buffer(header.length + body.length);
      header.copy(packet);
      body.copy(packet, header.length);
      return packet;
    };

    GameServer.prototype.sendToGcm = function(jsonData) {
      var _ref;
      return (_ref = this.gcmClient) != null ? _ref.write(makePacket(jsonData)) : void 0;
    };

    GameServer.prototype.gcmClient = null;

    GameServer.prototype.lastActionTime = 0;

    GameServer.prototype.onGcm = function(json) {
      var data;
      switch (json.msgType) {
        case 'chat':
          data = json.body;
          return this.world.processChat(data.user, null, data.msg);
      }
    };

    GameServer.prototype.connectToGcm = function(ip, port) {
      var buf, client;
      client = net.createConnection(port, ip);
      buf = new Buffer(0);
      client.on('error', (function(_this) {
        return function(err) {
          console.log('Error!!! try to reconnect after 10 secs');
          return setTimeout(function() {
            return _this.connectToGcm(ip, port);
          }, 10000);
        };
      })(this));
      client.on('connect', (function(_this) {
        return function() {
          console.log('Connected');
          _this.gcmClient = client;
          return _this.sendToGcm({
            msgType: 'chat',
            body: {
              user: 'John',
              msg: 'Hello, World wtf2 오호',
              time: Date.now()
            }
          });
        };
      })(this));
      client.on('data', (function(_this) {
        return function(data) {
          var json, jsonBegin, jsonEnd, jsonSize, jsonStr, match, matchSize, newBuf, nextPos, str, _results;
          newBuf = new Buffer(buf.length + data.length);
          buf.copy(newBuf);
          data.copy(newBuf, buf.length);
          buf = newBuf;
          _results = [];
          while (true) {
            str = buf.toString('utf8');
            match = /^(\d+)\r?\n\r?\n/.exec(str);
            if (!match) {
              break;
            }
            matchSize = match[0].length;
            jsonSize = parseInt(match[1]);
            nextPos = match.index + matchSize + jsonSize;
            if (buf.length < nextPos) {
              break;
            }
            jsonBegin = match.index + matchSize;
            jsonEnd = jsonBegin + jsonSize;
            jsonStr = buf.toString('utf8', jsonBegin, jsonEnd);
            json = JSON.parse(jsonStr);
            _this.onGcm(json);
            _results.push(buf = buf.slice(nextPos));
          }
          return _results;
        };
      })(this));
      return client.on('close', (function(_this) {
        return function() {
          return console.log('Connection closed');
        };
      })(this));
    };

    return GameServer;

  })();

  module.exports = function(server) {
    var gameServer;
    gameServer = new GameServer(server);
    return gameServer.init();
  };

}).call(this);

//# sourceMappingURL=gameServer.map
