// Generated by CoffeeScript 1.6.3
(function() {
  var root;

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  root.Player = cc.Sprite.extend({
    ctor: function(name, sprite) {
      var animFrames, createMoveAction, frame, height, i, j, texSize, texture, width, _i, _j;
      texture = cc.textureCache.addImage("res/" + sprite + ".png");
      texSize = texture.getContentSize();
      width = texSize.width / 4;
      height = texSize.height / 4;
      animFrames = [];
      for (i = _i = 0; _i < 4; i = ++_i) {
        for (j = _j = 0; _j < 4; j = ++_j) {
          frame = cc.SpriteFrame.create(texture, cc.rect(width * j, height * i, width, height));
          animFrames.push(frame);
        }
      }
      this._super(animFrames[0]);
      createMoveAction = function(begin, end) {
        var animate, animation, seq;
        animation = cc.Animation.create(animFrames.slice(begin, +end + 1 || 9e9), 0.2);
        animate = cc.Animate.create(animation);
        seq = cc.Sequence.create(animate);
        return cc.RepeatForever.create(seq);
      };
      this.moveAction = {
        down: createMoveAction(0, 3),
        left: createMoveAction(4, 7),
        right: createMoveAction(8, 11),
        up: createMoveAction(12, 15)
      };
      this.nowAction = this.moveAction.down;
      return this.runAction(this.nowAction);
    },
    setMapPos: function(x, y) {
      var dX, dY, newAction;
      dX = x - this.mX;
      dY = y - this.mY;
      if (dX > 0) {
        newAction = this.moveAction.right;
      } else if (dX < 0) {
        newAction = this.moveAction.left;
      } else if (dY > 0) {
        newAction = this.moveAction.up;
      } else if (dY < 0) {
        newAction = this.moveAction.down;
      }
      if (newAction && newAction !== this.nowAction) {
        this.stopAction(this.nowAction);
        this.nowAction = newAction;
        this.runAction(this.nowAction);
      }
      this.mX = x;
      return this.mY = y;
    }
  });

  root.GameLayer = cc.Layer.extend({
    init: function() {
      var param, size, tileMapTag;
      this._super();
      size = cc.director.getWinSize();
      tileMapTag = 337;
      this.tileMap = cc.TMXTiledMap.create(res.Test_tmx);
      this.addChild(this.tileMap, 0, tileMapTag);
      this.tileMap.anchorX = 0;
      this.tileMap.anchorY = 0;
      cc.director.setProjection(cc.Director.PROJECTION_2D);
      if ('keyboard' in cc.sys.capabilities) {
        param = {
          event: cc.EventListener.KEYBOARD,
          onKeyPressed: function(key, event) {
            return g.keys[key] = true;
          },
          onKeyReleased: function(key, event) {
            return g.keys[key] = false;
          }
        };
        cc.eventManager.addListener(param, this);
      }
      this.scheduleUpdate();
      this.others = {};
      return true;
    },
    map2screen: function(x, y) {},
    update: function(dt) {
      var dX, dY, mX, mY, mapPos, mapSize, move, moves, name, other, player, quit, quits, size, sprite, x, y, _i, _j, _len, _len1, _ref, _ref1;
      size = cc.director.getWinSize();
      if (g.logged === false && g.name && g.sprite) {
        this.avatar = new Player(g.name, g.sprite);
        this.avatar.x = size.width / 2;
        this.avatar.y = size.height / 2;
        this.avatar.mX = this.avatar.x;
        this.avatar.mY = this.avatar.y;
        this.addChild(this.avatar, 1);
        g.logged = true;
      }
      moves = g.moves;
      g.moves = [];
      for (_i = 0, _len = moves.length; _i < _len; _i++) {
        move = moves[_i];
        name = move.name;
        sprite = move.sprite;
        x = move.x;
        y = move.y;
        if (name in this.others) {
          player = this.others[name];
          player.setMapPos(x, y);
          player.x = x;
          player.y = y;
        } else {
          player = new Player(name, sprite);
          player.setMapPos(x, y);
          player.x = x;
          player.y = y;
          this.tileMap.addChild(player, 1);
          this.others[name] = player;
        }
      }
      quits = g.quits;
      g.quits = [];
      for (_j = 0, _len1 = quits.length; _j < _len1; _j++) {
        quit = quits[_j];
        if (quit in this.others) {
          other = this.others[quit];
          this.tileMap.removeChild(other);
          delete this.others[quit];
        }
      }
      if (!cc.sys.isNative) {
        if (!this.avatar) {
          return;
        }
        mapSize = this.tileMap.getContentSize();
        _ref = [this.avatar.mX, this.avatar.mY], mX = _ref[0], mY = _ref[1];
        _ref1 = [0, 0], dX = _ref1[0], dY = _ref1[1];
        if (g.keys[cc.KEY.right] && mX < mapSize.width) {
          dX += 3;
        }
        if (g.keys[cc.KEY.left] && mX > 0) {
          dX -= 3;
        }
        if (g.keys[cc.KEY.up] && mY < mapSize.height) {
          dY += 3;
        }
        if (g.keys[cc.KEY.down] && mY > 0) {
          dY -= 3;
        }
        this.avatar.setMapPos(mX + dX, mY + dY);
        if (dX !== 0 || dY !== 0) {
          socket.emit('cMove', {
            x: this.avatar.mX,
            y: this.avatar.mY
          });
        }
        mapPos = this.tileMap.getPosition();
        mapPos.x = size.width / 2 - this.avatar.mX;
        mapPos.y = size.height / 2 - this.avatar.mY;
        return this.tileMap.setPosition(mapPos);
      }
    }
  });

  root.GameScene = cc.Scene.extend({
    onEnter: function() {
      var layer;
      this._super();
      layer = new GameLayer();
      layer.init();
      return this.addChild(layer);
    }
  });

}).call(this);

/*
//@ sourceMappingURL=gameScene.map
*/
