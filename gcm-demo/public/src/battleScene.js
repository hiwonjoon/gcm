// Generated by CoffeeScript 1.7.1
(function() {
  var root;

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  if (root.debug == null) {
    root.debug = {};
  }

  root.Actions = {
    attack: 0,
    defend: 1,
    skill: 2,
    flee: 3
  };

  root.BattleStatus = {
    playerTurn: 0,
    opponentTurn: 1
  };

  root.BattleResult = {
    draw: 0,
    lose: 1,
    win: 2
  };

  root.BattleLayer = cc.Layer.extend({
    actions: [],
    status: BattleStatus.playerTurn,
    defenceMode: false,
    processEndBattle: function(winner, loser, isDraw) {
      return this.callAfter(4.0, (function(_this) {
        return function() {
          return cc.director.popScene();
        };
      })(this));
    },
    processAttack: function(fromName, toName, isSkill, damage, hp) {
      var actionTo, after, emitter, from, to, _ref, _ref1;
      if (this.me.name === fromName) {
        _ref = [this.me, this.enemy], from = _ref[0], to = _ref[1];
      } else {
        _ref1 = [this.enemy, this.me], from = _ref1[0], to = _ref1[1];
      }
      if (isSkill) {
        emitter = cc.ParticleFire.create();
        emitter.setEmitterMode(1);
      } else {
        emitter = cc.ParticleGalaxy.create();
        emitter.setShapeType(cc.ParticleSystem.BALL_SHAPE);
        emitter.setTotalParticles(100);
      }
      emitter.texture = cc.textureCache.addImage(res.fire_png);
      emitter.setPosition(from.getPosition());
      this.addChild(emitter);
      emitter.setScale(1);
      emitter.setAutoRemoveOnFinish(true);
      emitter.setDuration(1);
      emitter.setLife(0.5);
      actionTo = cc.MoveTo.create(1, to.getPosition());
      after = cc.CallFunc.create((function(_this) {
        return function() {
          var color, damageAction, tint;
          to.setHp(hp);
          color = to.getColor();
          tint = cc.Sequence.create(cc.TintTo.create(0.7, 255, 0, 0), cc.TintTo.create(0.3, color.r, color.g, color.b));
          damageAction = cc.Spawn.create([cc.Blink.create(1, 3), tint]);
          return to.runAction(damageAction);
        };
      })(this));
      emitter.runAction(cc.Sequence.create(actionTo, after));
      return hp === 0;
    },
    processPlayerFlee: function() {
      return this.callAfter(4.0, (function(_this) {
        return function() {
          return cc.director.popScene();
        };
      })(this));
    },
    statusLabel: null,
    setStatusText: function(status) {
      if (this.statusLabel) {
        this.removeChild(this.statusLabel);
      }
      this.statusLabel = cc.LabelBMFont.create(status, res.littera01_fnt, 50);
      this.statusLabel.setScale(1.5);
      this.statusLabel.setPosition(cc.p(500, 400));
      return this.addChild(this.statusLabel, 2);
    },
    init: function() {
      var action, bg, drawBounds, drawShadow, fadeIn, fadeOut, fadeSeq, forever, i, k, label, minScale, param, size, v, xScale, yScale;
      this._super();
      for (k in Actions) {
        v = Actions[k];
        this.actions[v] = k.toString().toUpperCase();
      }
      size = cc.director.getWinSize();
      bg = cc.Sprite.create(res.battle_png);
      xScale = size.width / bg.width;
      yScale = size.height / bg.height;
      minScale = Math.min(xScale, yScale);
      bg.setScale(minScale);
      bg.setPosition(size.width / 2, size.height / 2);
      this.addChild(bg, -1);
      this.me = g.me ? new Player(g.me.name, g.me.sprite) : new Player('mario', '08sprite');
      this.enemy = g.enemy ? g.enemyIsNpc ? new Npc(g.enemy.name, g.enemy.sprite) : new Player(g.enemy.name, g.enemy.sprite) : new Player('luigi', '17sprite');
      if (g.firstAttack) {
        this.setStatusText('PlayerTurn');
        this.status = BattleStatus.playerTurn;
      } else {
        this.setStatusText('Waiting...');
        this.status = BattleStatus.opponentTurn;
      }
      this.me.moveUp();
      this.enemy.moveDown();
      this.me.setScale(3.5);
      this.me.setPosition(size.width * 80 / 400, size.height * 30 / 238);
      this.enemy.setScale(2.0);
      this.enemy.setPosition(size.width * 292 / 400, size.height * 110 / 238);
      this.addChild(this.me, 0);
      this.addChild(this.enemy, 0);
      drawBounds = cc.DrawNode.create();
      drawBounds.drawRect(cc.p(30, 300), cc.p(350, 430), cc.color(10, 10, 10, 255), 5, cc.color(120, 120, 120, 255));
      this.addChild(drawBounds, 1);
      drawShadow = cc.DrawNode.create();
      drawShadow.drawDot(cc.p(100, 100), 30, cc.color(20, 20, 20, 255));
      for (action in Actions) {
        i = Actions[action];
        label = cc.LabelBMFont.create(action.toString().toLowerCase(), res.littera02_fnt, 12);
        label.setPosition(cc.p(100, 410 - 30 * i));
        this.addChild(label, 2);
      }
      this.arrow = cc.Sprite.create(res.leftarrow_png);
      this.arrow.setScale(0.3);
      this.arrow.setPosition(cc.p(230, 410));
      this.addChild(this.arrow, 2);
      fadeIn = cc.FadeIn.create(0.5);
      fadeOut = cc.FadeOut.create(0.5);
      fadeSeq = cc.Sequence.create(fadeIn, fadeOut);
      forever = cc.RepeatForever.create(fadeSeq);
      this.scheduleUpdate();
      if ('keyboard' in cc.sys.capabilities) {
        param = {
          event: cc.EventListener.KEYBOARD,
          onKeyPressed: (function(_this) {
            return function(key, event) {
              if (_this.status !== BattleStatus.playerTurn) {
                return;
              }
              switch (key) {
                case 40:
                  console.log('down');
                  if (_this.selectedIndex < 3) {
                    return _this.selectedIndex++;
                  }
                  break;
                case 38:
                  console.log('up');
                  if (_this.selectedIndex > 0) {
                    return _this.selectedIndex--;
                  }
                  break;
                case 39:
                  return console.log('left');
                case 37:
                  return console.log('right');
              }
            };
          })(this),
          onKeyReleased: (function(_this) {
            return function(key, event) {
              if (_this.status !== BattleStatus.playerTurn) {
                return;
              }
              console.log(key);
              switch (key) {
                case 70:
                  console.log(_this.selectedIndex);
                  switch (_this.actions[_this.selectedIndex]) {
                    case 'ATTACK':
                      socket.emit('cAttack', {
                        isSkill: false
                      });
                      break;
                    case 'SKILL':
                      socket.emit('cAttack', {
                        isSkill: true
                      });
                      break;
                    case 'DEFEND':
                      socket.emit('cDefend');
                      break;
                    case 'FLEE':
                      socket.emit('cFlee');
                  }
                  _this.status = BattleStatus.opponentTurn;
                  return _this.setStatusText('Waiting...');
              }
            };
          })(this)
        };
        return cc.eventManager.addListener(param, this);
      }
    },
    callAfter: function(after, callback) {
      var delay;
      delay = cc.DelayTime.create(3.0);
      after = cc.CallFunc.create((function(_this) {
        return function() {
          return callback();
        };
      })(this));
      return this.runAction(cc.Sequence.create(delay, after));
    },
    selectedIndex: 0,
    update: function(dt) {
      var data, msgType, packet, packets, size, _i, _len, _ref, _results;
      size = cc.director.getWinSize();
      this.arrow.setPosition(cc.p(250, 410 - 30 * this.selectedIndex));
      packets = g.packets;
      g.packets = [];
      _results = [];
      for (_i = 0, _len = packets.length; _i < _len; _i++) {
        packet = packets[_i];
        msgType = packet.msgType;
        data = packet.data;
        switch (msgType) {
          case 'sAttack':
            console.log('sAttack', data);
            _results.push(this.processAttack(data.from, data.to, data.isSkill, data.damage, data.hp));
            break;
          case 'sBattleStatus':
            this.setStatusText(data.msg);
            _results.push(this.status = data.turn ? BattleStatus.playerTurn : BattleStatus.opponentTurn);
            break;
          case 'sEndBattle':
            _results.push(this.processEndBattle(data.winner, data.loser, data.isDraw));
            break;
          default:
            _results.push((_ref = g.world) != null ? _ref.handlePacket(msgType, data) : void 0);
        }
      }
      return _results;
    }
  });


  /*
  
  
      delay = cc.DelayTime.create 10.0
      change = cc.CallFunc.create ->
        cc.director.popScene()
  
       *@runAction cc.Sequence.create(delay, change)
  
       * keyboard 핸들러 등록
   */

  root.BattleScene = cc.Scene.extend({
    onEnter: function() {
      var layer;
      this._super();
      layer = new BattleLayer;
      layer.init();
      return this.addChild(layer);
    }
  });

}).call(this);

//# sourceMappingURL=battleScene.map
