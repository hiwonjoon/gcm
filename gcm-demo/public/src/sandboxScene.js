// Generated by CoffeeScript 1.7.1

/*
  var DemoFirework = ParticleDemo.extend({
    onEnter:function () {
        this._super();

        this._emitter = cc.ParticleFireworks.create();
        this._background.addChild(this._emitter, 10);
        var myTexture = cc.textureCache.addImage(s_stars1);
        this._emitter.texture = myTexture;
        if (this._emitter.setShapeType)
            this._emitter.setShapeType(cc.ParticleSystem.STAR_SHAPE);
        this.setEmitterPosition();
    },
    title:function () {
        return "ParticleFireworks";
    }
});
 */

(function() {
  var root;

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  root.SandNpc = cc.Sprite.extend({
    ctor: function(name, sprite) {
      var animFrames, createMoveAction, frame, height, i, j, texSize, texture, width, _i, _j;
      texture = cc.textureCache.addImage(sprite);
      texSize = texture.getContentSize();
      width = texSize.width / 4;
      height = texSize.height / 4;
      animFrames = [];
      for (i = _i = 0; _i < 4; i = ++_i) {
        for (j = _j = 0; _j < 4; j = ++_j) {
          frame = cc.SpriteFrame.create(texture, cc.rect(width * j, height * i, width, height));
          animFrames.push(frame);
        }
      }
      this._super(animFrames[0]);
      createMoveAction = function(begin, end) {
        var animate, animation, seq;
        animation = cc.Animation.create(animFrames.slice(begin, +end + 1 || 9e9), 0.2);
        animate = cc.Animate.create(animation);
        seq = cc.Sequence.create(animate);
        return cc.RepeatForever.create(seq);
      };
      this.moveAction = {
        down: createMoveAction(0, 3),
        left: createMoveAction(4, 7),
        right: createMoveAction(8, 11),
        up: createMoveAction(12, 15)
      };
      this.nowAction = this.moveAction.down;
      return this.runAction(this.nowAction);
    },
    setMapPos: function(x, y) {
      var dX, dY, newAction;
      dX = x - this.mX;
      dY = y - this.mY;
      if (dX > 0) {
        newAction = this.moveAction.right;
      } else if (dX < 0) {
        newAction = this.moveAction.left;
      } else if (dY > 0) {
        newAction = this.moveAction.up;
      } else if (dY < 0) {
        newAction = this.moveAction.down;
      }
      if (newAction && newAction !== this.nowAction) {
        this.stopAction(this.nowAction);
        this.nowAction = newAction;
        this.runAction(this.nowAction);
      }
      this.mX = x;
      return this.mY = y;
    }
  });

  root.UiLayer = cc;

  root.SandboxLayer = cc.LayerRGBA.extend({
    init: function() {
      var actionTo, button2, drawHp, drawShadow, emitter, fileName, i, key, label, npc, npcSize, size, toX, toY, uiLayout, x, y, _i, _results;
      uiLayout = ccs.uiReader.widgetFromJsonFile('res/NewUI_1/NewUi_1.json');
      console.log(uiLayout);
      console.log(uiLayout.getChildren());
      console.log(uiLayout.getChildByName('ProgressBar_9'));
      button2 = uiLayout.getChildByName('Button_2');
      button2.setTitleText('테스트임당');
      button2.addTouchEventListener(function(obj, evt) {
        if (evt === ccui.Widget.TOUCH_ENDED) {
          return console.log(obj);
        }
      }, button2);
      this.addChild(uiLayout);
      return;
      size = cc.director.getWinSize();
      for (key in res) {
        continue;
        fileName = res[key];
        if (/res\/npc\//.test(fileName)) {
          cc.log(key);
          x = Math.random() * size.width;
          y = Math.random() * size.height;
          npc = new SandNpc(key, fileName);
          npc.x = x;
          npc.y = y;
          npcSize = npc.getContentSize();
          drawHp = cc.DrawNode.create();
          drawHp.drawRect(cc.p(0, npcSize.height + 2), cc.p(npcSize.width, npcSize.height + 10), cc.color(255, 0, 0, 255));
          drawShadow = cc.DrawNode.create();
          drawShadow.drawDot(cc.p(npcSize.width / 2, npcSize.height / 20), npcSize.width / 3, cc.color(100, 100, 100, 255));
          drawShadow.setScaleY(0.3);
          label = cc.LabelTTF.create(key, 'Consolas', 10);
          label.color = cc.color(200, 200, 200);
          label.setPosition(cc.p(npcSize.width / 2, npcSize.height + 20));
          npc.addChild(drawShadow, -1);
          npc.addChild(label, 1);
          npc.addChild(drawHp, 1);
          this.addChild(npc);
        }
      }
      _results = [];
      for (i = _i = 0; _i <= 10; i = ++_i) {
        emitter = cc.ParticleFire.create();
        emitter.texture = cc.textureCache.addImage(res.fire_png);
        emitter.setEmitterMode(1);
        x = 100;
        y = 200 + i * 30;
        toX = 500;
        toY = y;
        emitter.x = x;
        emitter.y = y;
        this.addChild(emitter);
        emitter.setScale(0.3);
        cc.log(emitter.autoRemoveOnFinish);
        cc.log(emitter.duration);
        cc.log(emitter.startColor);
        cc.log(emitter.endColor);
        cc.log(emitter.speed);
        cc.log(emitter.life);
        cc.log(emitter.totalParticles);
        cc.log('wow');
        cc.log(emitter.getContentSize().width);
        cc.log(emitter.getContentSize().height);
        emitter.setDuration(0.2);
        emitter.setLife(emitter.life * 0.1 * i);
        emitter.setStartColor(cc.color(0, 0, 255, 255));
        emitter.setEndColor(cc.color(0, 255, 0, 255));
        actionTo = cc.MoveTo.create(1, cc.p(toX, toY));
        _results.push(emitter.runAction(actionTo));
      }
      return _results;
    }
  });


  /*
      actionBy = cc.JumpBy.create(2, cc.p(300, 0), 50, 4)
      actionUp = cc.JumpBy.create(2, cc.p(0, 0), 80, 4)
      actionByBack = actionBy.reverse();
      delay = cc.DelayTime.create(0.25);
  
      this._tamara.runAction(actionTo);
      this._grossini.runAction(cc.Sequence.create(actionBy, delay, actionByBack));
      this._kathia.runAction(cc.RepeatForever.create(
        cc.Sequence.create(actionUp, delay.clone() )
      ) );
   */

  root.SandboxScene = cc.Scene.extend({
    onEnter: function() {
      var layer, whiteLayer;
      this._super();
      layer = new SandboxLayer;
      layer.init();
      whiteLayer = cc.LayerColor.create(cc.color(255, 255, 255, 255));
      return this.addChild(layer);
    }
  });

}).call(this);

//# sourceMappingURL=sandboxScene.map
